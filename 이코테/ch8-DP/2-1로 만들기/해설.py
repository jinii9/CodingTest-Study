# 정수 X를 입력 받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i - 1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])

#################################################
# DP 유형 파악 방법
## (함수 호출되는 과정 보면,) 함수들이 동일하게 여러 번 호출되는 것을 알 수 있음.

# 점화식
## 점화식을 떠올리자!

# DP 테이블
## (중요) DP 테이블에서 각 인덱스는 해당 숫자를 1로 만들기 위해 필요한 '최소 연산 횟수'를 의미
### d의 인덱스 : 정수 x
#### ex) d[10]은 정수 10을 1로 만드는 데 필요한 최소 연산 횟수를 저장한 위치
### d의 인덱스에 해당하는 값 : 최소 연산 횟수
#### ex) d[3]에 저장된 값이 2라면, 정수 3을 1로 만들기 위해 필요한 최소 연산 횟수가 2

# 인덱스 0과 1을 사용하지 않는 이유
## 주어진 숫자를 '1로 만들기' 위한 최소 연산 횟수를 구하는 것이므로, 우리는 숫자 1 이상에 대한 연산 횟수에만 관심이 있다. (1을 1로 만드는 데 필요한 연산 횟수는 0)

# '+ 1' 해주는 이유
## 함수의 호출 횟수 구해야 하기 때문에
