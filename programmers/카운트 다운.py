def solution(target):
    answer = []

    # 인덱스: 현재 점수, 값: [쏜 화살의 수, 불 또는 싱글을 쏜 횟수]
    dp = [[target-i, target-i] for i in range(target+1)]
    ## 각 인덱스(i)에는 현재 점수(i)에 도달하기 위해 필요한 '최소 다트 수', '싱글 or 불을 맞힌 횟수'를 저장한다. 
    ## [[21, 21], [20, 20], [19, 19], [18, 18], [17, 17], [16, 16], [15, 15], [14, 14], [13, 13], [12, 12], [11, 11], [10, 10], [9, 9], [8, 8], [7, 7], [6, 6], [5, 5], [4, 4], [3, 3], [2, 2], [1, 1], [0, 0]]
    
    for i in range(target, -1, -1): # 현재 점수 : i
        for j in range(20, 0, -1): # 다트의 점수
            
            # <불 점수의 경우>
            if i-50 >= 0:
                # 더 적은 화살 수로 갱신
                ## dp[i][0] + 1 : 현재 점수 i에서 불 점수(50점)을 더 쏘았다.
                ## "현재 점수 i에서 불 점수(50점)를 쏘고, i-50에 도달하기 위한 화살 수가 더 적으면 dp[i-50]를 갱신하겠다"
                if dp[i-50][0] > dp[i][0]+1: 
                    dp[i-50] = [dp[i][0]+1, dp[i][1]+1]

                # 화살 수가 같다면, 더 많이 쏜 볼 또는 싱글 수로 갱신
                elif dp[i-50][0] == dp[i][0]+1 and dp[i-50][1] < dp[i][1]+1:
                    dp[i-50] = [dp[i][0]+1, dp[i][1]+1]

            # <싱글 점수의 경우> : 현재 점수 - 다트의 점수
            if i-j >= 0:
                # 더 적은 화살 수로 갱신
                if dp[i-j][0] > dp[i][0]+1:
                    dp[i-j] = [dp[i][0]+1, dp[i][1]+1]

                # 더 많이 쏜 볼 또는 싱글 수로 갱신
                elif dp[i-j][0] == dp[i][0]+1 and dp[i-j][1] < dp[i][1]+1:
                    dp[i-j] = [dp[i][0]+1, dp[i][1]+1]
            
            # <현재 점수(i)에서 j를 뺄 수 없을 경우>
            else:
                break

            # <더블 점수의 경우>
            if i-2*j >= 0:
                # 더 적게 쏴서 도달할 수 있을 때,
                if dp[i-2*j][0] > dp[i][0]+1:
                    dp[i-2*j] = [dp[i][0]+1, dp[i][1]]

                # 같은 수를 쐇지만, 볼 또는 싱글을 더 많이 맞출때
                elif dp[i-2*j][0] == dp[i][0]+1 and dp[i-2*j][1] < dp[i][1]:
                    dp[i-2*j] = [dp[i][0]+1, dp[i][1]]

            # <트리플 점수의 경우>
            if i-3*j >= 0:
                # 더 적게 쏴서 도달할 수 있을 때,
                if dp[i-3*j][0] > dp[i][0]+1:
                    dp[i-3*j] = [dp[i][0]+1, dp[i][1]]

                # 같은 수를 쐇지만, 볼 또는 싱글을 더 많이 맞출때
                elif dp[i-3*j][0] == dp[i][0]+1 and dp[i-3*j][1] < dp[i][1]:
                    dp[i-3*j] = [dp[i][0]+1, dp[i][1]]


    return dp[0] # 0점을 만들기 위한 '최소 화살 수'와 '싱글or불을 맞힌 횟수' 반환